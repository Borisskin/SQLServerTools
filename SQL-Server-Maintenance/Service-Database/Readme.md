# Служебная база обслуживания и мониторинга

База данных предоставляет набор служебных объектов для выполнения настраиваемых операций обслуживания и мониторинга.

- [Служебная база обслуживания и мониторинга](#служебная-база-обслуживания-и-мониторинга)
  - [Создание базы](#создание-базы)
    - [Простой скрипт](#простой-скрипт)
    - [Миграции с поддержкой версионирования и обновления](#миграции-с-поддержкой-версионирования-и-обновления)
  - [Доступные операции](#доступные-операции)
  - [Примеры использования](#примеры-использования)
    - [Сбор информации о размере таблиц](#сбор-информации-о-размере-таблиц)
    - [Сбор информации о состоянии объектов базы данных](#сбор-информации-о-состоянии-объектов-базы-данных)
    - [Сбор информации о соединениях](#сбор-информации-о-соединениях)
    - [Быстрая настройка и управление расширенными событиями](#быстрая-настройка-и-управление-расширенными-событиями)
    - [Обслуживание индексов](#обслуживание-индексов)
      - [Обслуживание индексов во всех базах](#обслуживание-индексов-во-всех-базах)
      - [Обслуживание индексов в конкретной базе](#обслуживание-индексов-в-конкретной-базе)
      - [Обслуживание индексов по конкретной таблице с учетом сохраненных данных о состоянии объектов](#обслуживание-индексов-по-конкретной-таблице-с-учетом-сохраненных-данных-о-состоянии-объектов)
      - [Обслуживание индексов с отбором по таблице и индексу](#обслуживание-индексов-с-отбором-по-таблице-и-индексу)
      - [Возобновляемое перестроение индексов](#возобновляемое-перестроение-индексов)
      - [Условия выполнения обслуживания](#условия-выполнения-обслуживания)
      - [Указание процента заполнения страниц](#указание-процента-заполнения-страниц)
      - [Логи обслуживания индексов](#логи-обслуживания-индексов)
    - [Обслуживание статистик](#обслуживание-статистик)
      - [Обновим статистику во всех базах](#обновим-статистику-во-всех-базах)
      - [Обновление статистики для конкретной базы полным сканированием](#обновление-статистики-для-конкретной-базы-полным-сканированием)
      - [Обновление статистики для конкретной таблицы](#обновление-статистики-для-конкретной-таблицы)
      - [Настройка приоритета и исключений для индексов](#настройка-приоритета-и-исключений-для-индексов)
      - [Логи обслуживания статистик](#логи-обслуживания-статистик)
    - [Управление заданиями](#управление-заданиями)
      - [Шаблоны заданий](#шаблоны-заданий)
    - [Сервисные функции](#сервисные-функции)
      - [Контроль времени выполнения](#контроль-времени-выполнения)
      - [Контроль логов транзакций](#контроль-логов-транзакций)
      - [Контроль блокировок запросов](#контроль-блокировок-запросов)
      - [Реорганизация индексов и блокировки на уровне страниц](#реорганизация-индексов-и-блокировки-на-уровне-страниц)
      - [Исправление системного кэша объектов для реплик AlwaysOn](#исправление-системного-кэша-объектов-для-реплик-alwayson)
      - [Сжатие и "умный" шринк (shrink) базы данных](#сжатие-и-умный-шринк-shrink-базы-данных)
      - [Печать длинных сообщений](#печать-длинных-сообщений)
    - [Сервисные функции для баз 1С](#сервисные-функции-для-баз-1с)
      - [Функции рабботы с уникальными идентификаторами](#функции-рабботы-с-уникальными-идентификаторами)
    - [Бэкапирование](#бэкапирование)
      - [Формирование бэкапов](#формирование-бэкапов)
      - [Очистка бэкапов](#очистка-бэкапов)

Далее рассмотрим примеры работы с этой базой данных.

## Создание базы

Имеется два пути создания служебной базы.

### Простой скрипт

Самый простой и быстрый способ - это использовать [скрипт](CreateServiceDatabaseScript.sql), создающий все необходимые объекты в пустой базе данных.

Таким образом, алгоритм создания служебно базы будет следующим:

- Создаем вручную пустую базу с именем **SQLServerMaintenance**.
- В котнексте созданной базы выполняем [скрипт](CreateServiceDatabaseScript.sql).

Все, база готова для использования.

**Плюсы:**

- Простота создания базы с нуля.

**Минусы:**

- Нет возможности простой установки обновлений на эту базу данных. При необходимости обновления чаще всего нужно будет "вычленять" изменения вручную из новых версий скриптов.

### Миграции с поддержкой версионирования и обновления

Другой подход - это использование миграций. Каждая миграция - это набор действий, который изменяет версию базы данных. Все миграции находятся в каталоге [Migrations](Migrations) и имеют имена в формате:

```text
V1_3_1_1__MigrationName.sql.

или

V<ВерсияМиграции>__<ИмяМиграции>.sql
```

Использовать миграции также можно двумя путями:

- Запускать последовательно скрипты мигарций на пустой базе. А при появлении новых миграций - запускать их уже на существующей базе для обновления.
- Использовать решение [Evolve](https://github.com/lecaillon/Evolve), которе авматизирует процесс применения данных миграций на базе данных. Вместо ручного запуска можно выполнить команду вида:

```pwsh
# **migrate** - говорим, что нужно применить миграции.
# **sqlserver** - указываем тип СУБД (есть поддержка PostgreSQL и многих других)
# **-c** (строка подключения) - параметры подключения к базе.
# **-l** - каталог со списком миграций.

./evolve migrate sqlserver -c "Server=localhost;Database=SQLServerMaintenance;User Id=sa;Password=<ПарольПользователя>;" -l "/home/ypermitin/Develop/SQLServerTools/SQL-Server-Maintenance/Service-Database/Migrations"
```

Таким образом, с помощью миграций можно в простой манере создать и поддерживать актуальность базы данных. При этом версия изменений базы данных будет наглядна сохранена в системе контроля версий.

**Плюсы:**

- Прозрачный процесс создания и обновления базы данных.
- Возможность автоматизации обновления базы. CI/CD и все дела.

**Минусы:**

- Сложнее, чем один единственный скрипт.

Рекомендую использовать именно миграции.

## Доступные операции

Служебная база содержит следующие доступные операции:

- Обслуживание индексов.
- Обслуживание  статистик.
- Сбор информации о размерах таблиц баз данных на сервере.
- Служебные действия по настройке и исправлению некоторых проблем.
- Бэкапирование.
- Очистка файлов.
- Контроль работы заданий, обслуживания, а также любых других скриптов и операций в части времени выполнения, использования лога транзакций и обнаружение блокирующих запросов.
- Настройка мониторинга тяжелых запросов по ЦП, чтениям, а также ожидания на блокировках.
- Операции сжатия данных в базах и "умного" шринка файла данных частями.
- Шаблоны заданий (job'ы) общих для экземпляра или отдельные для каждой базы. Имеются готовые наборы шаблонов.
- Механизм настроек и поддержания их в базе данных для платформы 1С. Используется для гибких настроек объектов баз данных, которые не поддерживаются штатными средствами.

Кроме этого, все операции обслуживания логируются, что позволяет диагностировать их работу, находить узкие места и делать более гибкие настройки обслуживания.

Рассмотрим примеры работы с ними.

## Примеры использования

### Сбор информации о размере таблиц

Важно собирать информацию о динамике изменения размера таблиц баз данных на сервере. Для этого можно настроить задание с расписанием запуска 1 раз в сутки, вызывающий следующий скрипт:

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_SaveDatabasesTablesStatistic]
```

В результате будет собрана подробная информация о размерах таблиц каждой базы на сервере. Результаты записываются в таблицу "DatabasesTablesStatistic". Вот пример данных:
               |
| Period                      | DatabaseName | SchemaName | TableName             | RowCnt   | Reserved | Data    | IndexSize | Unused |
| --------------------------- | ------------ | ---------- | --------------------- | -------- | -------- | ------- | --------- | ------ |
| 2022-01-03 10:31:36.1000000 | SomeDatabase     | dbo        | \_AccRgED9823          | 18917980 | 4461736  | 1645064 | 2816440   | 232    |
| 2022-01-03 10:31:36.1033333 | SomeDatabase     | dbo        | \_AccRg9786            | 4659752  | 3003232  | 1637968 | 1364824   | 440    |
| 2022-01-03 10:31:36.1033333 | SomeDatabase     | dbo        | \_AccRgAT92820         | 647989   | 327520   | 313936  | 9560      | 4024   |
| 2022-01-03 10:31:36.1033333 | SomeDatabase     | dbo        | \_AccRgAT93821         | 6251900  | 3011736  | 2957568 | 54112     | 56     |
| 2022-01-03 10:31:36.1033333 | SomeDatabase     | dbo        | \_Document9239\_VT95716 | 1278     | 264280   | 263832  | 120       | 328    |

Таблица содержит информацию о каждой таблице базы данных на определенную дату:

- Количество записей (RowCnt)
- Размер данных, КБ (Data)
- Размер индексов, КБ (IndexSize)
- Неиспользованное место, КБ (Unused)
- Места зарезервировано всего, КБ (Reserved). Reserved = Data + IndexSize + Unused.

### Сбор информации о состоянии объектов базы данных

Анализ состояния объектов базы перед обслуживанием можем быть дорогостоящей и долгой операцией. Эта функция позволяет предварительно сохранить сотояние объектов в служебную базу, а потом использовать эту информацию при запуске скриптов обслуживания. Или для анализа состояния базы и эффективности самого обслуживания.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_FillDatabaseObjectsState] 
   @databaseName = 'bsl_2_4_2'
```

Таблица **DatabaseObjectsState** с сохраненными данными содержит:

- Период сохранения записи
- Имя базы
- Имя таблицы
- Имя объекта (обычно индекса)
- Размер объекта в страницах (1 страница = 8 КБ)
- Количество измененных строк с момента последнего обслуживания статистики
- Средний процент фрагментации индекса
- Признак поддержки онлайн-перестроения индекса

В общем, применению этой информации место всегда можно найти.

### Сбор информации о соединения с базой данных

Процедура сохраняет срез всех соединения с базой данных в таблицу **ConnectionsStatistic** для последующего анализа.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_FillConnectionsStatistic]
```

Таблица **ConnectionsStatistic** с сохраненными данными содержит всю ту информацию, которая возвращается из системного объекта **[sys.dm_exec_requests](https://docs.microsoft.com/ru-ru/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-requests-transact-sql?view=sql-server-ver15)**.

### Сбор информации о соединениях

Может потребоваться сбор информации о соединениях, например, для аудита доступа к базе или для получения информации о выполняемых запросах по конкретным соединениям на момент времени.

Для сбора имеется процедура **sp_FillConnectionsStatistic**, для вызова которой достаточно выполнить:

```sql
EXECUTE @RC = [dbo].[sp_FillConnectionsStatistic]
```

В результате в таблицу "ConnectionsStatistic" будут сохранены следующие данные:

- **id** - идентификатор записи
- **Period** - дата сохранения записи
- **InstanceName** - имя инстанса SQL Server
- **QueryText** - текст запроса
- **RowCountSize** - количество возвращаемых записей
- **SessionId** - номер сессии соединения с сервером баз данных
- **Status** - статус выполнения запроса
- **Command** - тип команды (INSERT, UPDATE, DELETE и другие)
- **CPU** - затрачено времени ЦП
- **TotalElapsedTime** - всего затрачено времени
- **StartTime** - дата запуска операции
- **DatabaseName** - имя базы данных
- **BlockingSessionId** - идентификатор блокирующей сессии с сервером баз данных
- **WaitType** - тип ожидания запроса
- **WaitResource** - тип ожидания ресурса
- **OpenTransactionCount** - количество открытых транзакций
- **Reads** - количество прочитанных страниц
- **Writes** - количество записанных страниц
- **LogicalReads** - количество прочитанных страниц из кэша
- **GrantedQueryMemory** - объем выделенной памяти
- **UserName** - имя пользователя

Информация может быть использована для анализа работу пользователей на момент времени, количества соединений с базой данных и др.

Это лишь обобщенная информация. С помощью **[расширенных событий](../../SQL-Server-Diagnostics/Extended-Events/Readme.md)** можно собрать более детальную информацию о происходящем.

### Быстрая настройка и управление расширенными событиями

Имеется ряд процедур для быстрой настройки и управления расширенными событиями SQL Server (Extended Events) по сбору основных данных работы сервера:

* Ошибки в работе SQL Server
* Тяжелые запросы по использованию ЦП
* Тяжелые запросы по чтениям
* Таймауты и ожидания на блокировках

Для их создания и настройки можно либо вручную выполнять настройку скриптами, описаными в **[разделе диагностики](../../SQL-Server-Diagnostics/Extended-Events/Readme.md)**, либо выполнить следующую команду:

```sql
EXECUTE [dbo].[sp_CreateOrUpdateExtendedEventSessions] 
	-- Запуск сессий сбора данных после создания и настройки
	@startSessions = 1
	-- Путь для сохранения файлов лога расширенных событий
   ,@logPath = 'D:\LOGS_SQL'
```

Также имеется процедура для перезапуска сессий сбора данных:

```sql
EXECUTE [dbo].[sp_RestartMonitoringXEventSessions]
```

Сессии сбора данных настраиваются с общими параметрами. Для специфических ситуаций нужна более тонкая настройка.

### Обслуживание индексов

Для обслуживания индексов используется процедура "sp_IndexMaintenance", которая позволяет указать:

- Конкретную базу для обслуживания (@databaseName)
- Интервал времени, в который доступна работа скрипта (@timeFrom и @timeTo)
- Режим обслуживания индексов (@useOnlineIndexRebuild):

  - (0) - стандартное обслуживание
  - (1) - онлайн обслуживания и только для тех объектов, которые это поддерживают. Таблицы с устаревшими типами могут не поддерживать онлайн-перестроение и будут пропущены.
  - (2) - обслуживание только тех объектов, в которых онлайн-перестроение не поддерживается.
  - (3) - обслуживание индексов с онлайн-перестроением. Так где операция недоступна будет выполнено классическое перестроение индексов.

- Указать минимальный (@minIndexSizePages) и максимальный (@maxIndexSizePages) размер индекса при обслуживании в количестве страниц (1 страница = 8 КБ, @minIndexSizePages и @maxIndexSizePages, по умолчанию не заданы)
- Минимальный размер процента фрагментации (@fragmentationPercentMinForMaintenance, по умолчанию 10%)., с которого начинается любое обслуживание. Обычно это операция реорганизации, если процент не превышает процента, с которого начинается перестроение (по умолчанию 30%).
- Максимальный размер индекса в страницах, для которых может применяться операция реорганизации (@maxIndexSizeForReorganizingPages). По умолчанию 50 ГБ, то есть 6553600 страниц. Все что большего размера будет использовать только перестроение индекса, чтобы процесс обслуживания не подвисал на долгое время.
- Максимальный размер фрагментации (@fragmentationPercentForRebuild, по умолчанию 30%), с которого начинается перестроение (до этого операция реорганизации).
- Степень параллелизма (@maxDop), т.к. количество потоков для операции обслуживания (@maxDop, по умолчанию 8).
- Использование сохраненных ранее данных о состоянии объектов для операции обслуживания индекса (@usePreparedInformationAboutObjectsStateIfExists). Если включено и есть ранее сохраненные данные о состоянии объектов за последние 12 часов, то повторный анализ базы данных не будет выполнен. Позволяет избежать излишних операций ввода/вывода.
- Условие для отбора таблиц базы для обслуживания (@ConditionTableName, по умолчанию “LIKE ''%''“).
- Условие для отбора индексов базы для обслуживания (@ConditionIndexName, по умолчанию “LIKE ''%''“).
- Режим ожидания при онлайн перестроении индексов (@onlineRebuildAbortAfterWaitMode):

  - 0 - операция обслуживания будет бесконечно ожидать другие запросы.
  - 1 - операция обслуживания завершит себя по истечении таймаута ожидания.
  - 2 - операция обслуживания завершит блокирующий процесс по истечени таймаута ожидания.

- Максимальный процент заполнения журнала транзакций, после которого операции обслуживания останавливаются (@maxTransactionLogSizeUsagePercent).

- Использование возобновляемого перестроения индексов, если эта функциональность доступна (@useResumableIndexRebuildIfAvailable). Позволяет перестраивать индексы в несколько шагов с прерыванием операции, что позволяет останавливаться при перестроении и не заполнять полностью лог транзакций или разносить нагрузку от обслуживания на разное время. [Подробнее можно прочитать здесь](https://www.mssqltips.com/sqlservertip/4987/sql-server-2017-resumable-online-index-rebuilds/). По умолчанию не используется.

- Указание явного процента заполнения страниц при перестроении индексов ([fill factor](https://learn.microsoft.com/en-us/sql/relational-databases/indexes/specify-fill-factor-for-an-index?view=sql-server-ver16)). Для разных индексов можно установить разный коэф. заполнения страниц в зависимости от ситуации. Если не заполнен, то используется общая настройка на уровне сервера.

Вот несколько простых примеров обслуживания индексов.

#### Обслуживание индексов во всех базах

Вот простой скрипт для обслуживания индексов во всех базах стандартным способом.

```sql
DECLARE @command varchar(max) 
SELECT @command = 
'USE [?]
EXECUTE [SQLServerMaintenance].[dbo].[sp_IndexMaintenance]
 @databaseName =''?''
'
EXEC sp_MSforeachdb @command
```

Другие параметры не указываются, т.к. значения по умолчанию для простых случаев подходят без изменений.

#### Обслуживание индексов в конкретной базе

Сделаем обслуживание для коркретной базы.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_IndexMaintenance] 
   @databaseName = 'bsl_2_4_2'
   -- Разрешаем запуск скрипта с 01:00:00 до 04:00:00
  ,@timeFrom = '01:00:00'
  ,@timeTo = '04:00:00'
   -- Убираем мин. процент фрагментации для обслуживания, чтобы
   -- скрипт обслуживал все индексы вне зависимости от фрагментации
  ,@fragmentationPercentMinForMaintenance = 0
   -- Переопределяем степень параллелизма на 4
  ,@maxDop = 4
   -- Включаем использвоание онлайн-перестроения где это возможно.
   -- Для объектов, где операция недоступна, будет использоваться стандартная операция перестроения
  ,@useOnlineIndexRebuild = 3
```

Этот вариант больше походит на реальную задачу настройки обслуживания.

#### Обслуживание индексов по конкретной таблице с учетом сохраненных данных о состоянии объектов

Добавим условие на обслуживание конкретной таблицы и использование, если есть, ранее сохраненной информации о состоянии объектов базы данных. Так мы избежим запуска анализа объектов базы данных "на горячую". Может пригодиться, если есть несколько запусков скриптов обслуживания и каждый раз анализировать состояния объектов нет смысла, а иногда и долго.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_IndexMaintenance] 
   @databaseName = 'bsl_2_4_2'
   -- Разрешаем запуск скрипта с 01:00:00 до 04:00:00
  ,@timeFrom = '01:00:00'
  ,@timeTo = '04:00:00'
   -- Убираем мин. процент фрагментации для обслуживания, чтобы
   -- скрипт обслуживал все индексы вне зависимости от фрагментации
  ,@fragmentationPercentMinForMaintenance = 0
   -- Переопределяем степень параллелизма на 4
  ,@maxDop = 4
   -- Включаем использвоание онлайн-перестроения где это возможно.
   -- Для объектов, где операция недоступна, будет использоваться стандартная операция перестроения
  ,@useOnlineIndexRebuild = 3,
  -- Использовать сохраненное состояние объектов из служебной базы
  ,@usePreparedInformationAboutObjectsStateIfExists = 1,
   -- Только индексы одной таблицы
  ,@ConditionTableName = 'LIKE ''_InfoRg1234'''
```

Своего рода точечное обслуживание для особых объектов.

#### Обслуживание индексов с отбором по таблице и индексу

Можно сделать отбор обслуживаемых объектом более точечным.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_IndexMaintenance] 
   @databaseName = 'bsl_2_4_2'
   -- Разрешаем запуск скрипта с 01:00:00 до 04:00:00
  ,@timeFrom = '01:00:00'
  ,@timeTo = '04:00:00'
   -- Убираем мин. процент фрагментации для обслуживания, чтобы
   -- скрипт обслуживал все индексы вне зависимости от фрагментации
  ,@fragmentationPercentMinForMaintenance = 0
   -- Переопределяем степень параллелизма на 4
  ,@maxDop = 4
   -- Включаем использвоание онлайн-перестроения где это возможно.
   -- Для объектов, где операция недоступна, будет использоваться стандартная операция перестроения
  ,@useOnlineIndexRebuild = 3,
  -- Использовать сохраненное состояние объектов из служебной базы
  ,@usePreparedInformationAboutObjectsStateIfExists = 1,
   -- Только индексы одной таблицы
  ,@ConditionTableName = 'LIKE ''%_InfoRg%'''
  ,@ConditionIndexName = 'LIKE ''%_1%'''
```

Таким образом, можно делать обслуживание только определенных индексов у определенных таблиц. Выше мы обслуживаем таблицы с именем, содержащим "_InfoRg", при этом индексы должны включать "_1".

#### Возобновляемое перестроение индексов

Начиная со SQL Server 2017 появился функционал [возобновляемых операций перестроения индексов](https://www.mssqltips.com/sqlservertip/4987/sql-server-2017-resumable-online-index-rebuilds/).

Для использования этого функционала нужно указать следующие параметры.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_IndexMaintenance] 
   @databaseName = 'bsl_2_4_2'
   -- Разрешаем запуск скрипта с 01:00:00 до 04:00:00
  ,@timeFrom = '01:00:00'
  ,@timeTo = '04:00:00'
   -- Убираем мин. процент фрагментации для обслуживания, чтобы
   -- скрипт обслуживал все индексы вне зависимости от фрагментации
  ,@fragmentationPercentMinForMaintenance = 0
   -- Переопределяем степень параллелизма на 4
  ,@maxDop = 4
   -- Включаем использвоание онлайн-перестроения где это возможно.
   -- Для объектов, где операция недоступна, будет использоваться стандартная операция перестроения
  ,@useOnlineIndexRebuild = 3
  -- Если флаг установлен, то для онлайн-операций обслуживания будет выполняться возобновляемое перестроение.
  -- Если операция перестроения была прервана, то при следующем запуске она будет продолжена 
  -- с того же места, где была остановлена.
  ,@useResumableIndexRebuildIfAvailable = 1
```

Состояние всех возобновляемых операций перестроения индексов можно посмотреть запросом:

```sql
SELECT 
  total_execution_time, 
  percent_complete, 
  name,
  state_desc,
  last_pause_time,
  page_count
FROM sys.index_resumable_operations;
```

#### Условия выполнения обслуживания

Для стабильной процедуры обслуживания можно установить условия выполнения, предотвращающие аварии и контролирующие стабильность выполнения.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_IndexMaintenance] 
   @databaseName = 'bsl_2_4_2',
   -- Минимальный размер объекта в кол. страниц ()
   @minIndexSizePages = 6400, -- 6400 * 8 КБ = 51200 КБ = 50 МБ
   @maxIndexSizePages = 6553600, -- 6553600 * 8 КБ = 52428800 КБ = 51200 МБ = 50 ГБ
   -- Макс. размер объекта, для которых выполняется реорганизация
   @maxIndexSizeForReorganizingPages = 6553600, -- (50 ГБ)
   -- Процент использования лога транзакций, до которого позволено выполнять
   -- операции обслуживания
   @maxTransactionLogSizeUsagePercent = 50,
   -- Сколько разрешено использовать в логе транзакций в МБ
   @maxTransactionLogSizeMB = 76800 -- 75 ГБ
```

Эти условия позволяют более тонко обслуживать объекты базы в зависимости от ситуации.

#### Указание процента заполнения страниц

В некоторых случаях имеет смысл уменьшить стандартный процент заполнения страниц ([fill factor](https://learn.microsoft.com/en-us/sql/relational-databases/indexes/specify-fill-factor-for-an-index?view=sql-server-ver16)) при перестроении индексов со 100% до 90% или даже ниже. Это увеличит размер занимаемого дискового пространства объектами, но снизит увеличение фрагментации индексов при изменении данных в таблице. Позволяет снизить частоту и необходимость обслуживания объектов.

Для указания процента заполнения страниц в скрипте обслуживания индексов нужно установить параметр @fillFactorForIndex (от 1 до 100). По умолчанию используется настройка, заданная на уровне инстанса SQL Server.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_IndexMaintenance] 
   @databaseName = 'bsl_2_4_2',
   -- Процент заполнения страниц (fill factor)
   @fillFactorForIndex = 80
```

Если комбинировать эту настройку с условиями на индексы и таблицы, то можно устанавливать ее точечно для разных объектов, в зависимости от ситуации.

#### Логи обслуживания индексов

Лог операций обслуживания индексов хранится в таблице "MaintenanceActionsLog" и имеет примерно такой вид.

| Id | Period           | TableName     | IndexName        | Operation     | RunDate          | StartDate        | FinishDate       | DatabaseName | UseOnlineRebuild | Comment | IndexFragmentation | RowModCtr | SQLCommand | TransactionLogUsageBeforeMB | TransactionLogUsageAfterMB |
| -- | ---------------- | ------------- | ---------------- | ------------- | ---------------- | ---------------- | ---------------- | ------------ | ---------------- | ------- | ------------------ | --------- | ------------------------------------------------------------------------------------- | --- | --- |
| 1  | 03.01.2022 11:36 | \_InfoRg931551 | \_InfoRg931551\_1 | REBUILD INDEX | 03.01.2022 11:36 | 03.01.2022 11:36 | 03.01.2022 11:36 | SomeDatabase     | 0                |         | 99                 | 0         | ALTER INDEX \[\_InfoRg931551\_1\] ON \[dbo\].\[\_InfoRg31551\] REBUILD WITH (MAXDOP=8) | 10 | 230 |
| 2  | 03.01.2022 11:36 | \_InfoRg931551 | \_InfoRg931551\_2 | REBUILD INDEX | 03.01.2022 11:36 | 03.01.2022 11:36 | 03.01.2022 11:36 | SomeDatabase     | 0                |         | 90                 | 0         | ALTER INDEX \[\_InfoRg931551\_2\] ON \[dbo\].\[\_InfoRg31551\] REBUILD WITH (MAXDOP=8) | 230 | 340 |
| 3  | 03.01.2022 11:36 | \_InfoRg929031 | \_InfoRg929031\_1 | REBUILD INDEX | 03.01.2022 11:36 | 03.01.2022 11:36 | 03.01.2022 11:36 | SomeDatabase     | 0                |         | 89                 | 0         | ALTER INDEX \[\_InfoRg929031\_1\] ON \[dbo\].\[\_InfoRg29031\] REBUILD WITH (MAXDOP=8) | 340 | 350 |
| 4  | 03.01.2022 11:36 | \_InfoRg929031 | \_InfoRg929031\_2 | REBUILD INDEX | 03.01.2022 11:36 | 03.01.2022 11:36 | 03.01.2022 11:36 | SomeDatabase     | 0                |         | 84                 | 0         | ALTER INDEX \[\_InfoRg929031\_2\] ON \[dbo\].\[\_InfoRg29031\] REBUILD WITH (MAXDOP=8) | 350 | 600 |
| 5  | 03.01.2022 11:36 | \_InfoRg929073 | \_InfoRg929073\_1 | REBUILD INDEX | 03.01.2022 11:36 | 03.01.2022 11:36 | 03.01.2022 11:36 | SomeDatabase     | 0                |         | 82                 | 0         | ALTER INDEX \[\_InfoRg929073\_1\] ON \[dbo\].\[\_InfoRg929073\] REBUILD WITH (MAXDOP=8) | 600 | 9399 |

Лог содержит информацию:

- Период операции (Period)
- Имя таблицы (TableName)
- Имя индекса (IndexName)
- Имя операции. Для индексов это либо "REORGANIZE INDEX", либо "REBUILD INDEX" (Operation)
- Дата запуска обслуживания (RunDate)
- Дата старта (StartDate)
- Дата завершения. Если дата завершения NULL, то значит операция обслуживания не была завершена успешно (FinishDate)
- Имя базы (DatabaseName)
- Признак использования операции онлайн-перестроения индекса (UseOnlineRebuild)
- Произвольный комментарий, обычно заполняется при ошибках (Comment)
- Процент фрагментации индекса перед обслуживанием (IndexFragmentation)
- Количество измененных строк до обслуживания индекса (RowModCtr)
- SQL-команда обслуживания индекса (SQLCommand)
ы

Лог позволяет определить эффективность обслуживания статистики и предпринять различные меры по ее актуализации.

### Обслуживание статистик

Для обслуживания объектов статистики используется процедура "sp_StatisticMaintenance", которая позволяет указать:

- Конкретную базу для обслуживания (databaseName)
- Интервал времени, в который доступна работа скрипта (timeFrom и timeTo)
- Режим обслуживания статистики (mode, 0 - по выборке, 1 - полное сканирование, по умолчанию 0) (по выборке данных или полным сканированием). Полное сканирование дает более точный результат, но может занять длительное время, в то время как анализ выборки данных значительно ускоряет этот процесс. [Подробнее здесь](https://docs.microsoft.com/ru-ru/sql/t-sql/statements/update-statistics-transact-sql?view=sql-server-ver15).
- Указать произвольное условие обслуживания на имя таблиц (если нужно настроить гибкое обслуживания по таблицам). (ConditionTableName, по умолчанию не используется)

Вот несколько простых примеров.

#### Обновим статистику во всех базах

Следующий скрипт выполняет обновление статистики во всех базах на сервере по выборке данных.

```sql
DECLARE @command varchar(max) 
SELECT @command = 
'USE [?]
EXECUTE [SQLServerMaintenance].[dbo].[sp_StatisticMaintenance] 
   @databaseName =''?''
' 
EXEC sp_MSforeachdb @command
```

По умолчанию обновление выполняется в режиме выборки данных, поэтому скрипт отработает достаточно быстро.

#### Обновление статистики для конкретной базы полным сканированием

Настроим скрипт, который обновляет статистику полным сканированием в определенной базе данных, при этом разрешенное время работы скрипта с 02:00:00 до 03:00:00.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_StatisticMaintenance] 
   @databaseName = 'SomeDatabase'
  ,@timeFrom = '02:00:00'
  ,@timeTo = '03:00:00'
  ,@mode = 1 -- 0 устанавливаем режим анализа выборки данных, 1 - режим полного сканирования
```

#### Обновление статистики для конкретной таблицы

Иногда бывает необходимо выполнять обслуживание статистик для опредленной таблицы отдельно от основного обслуживания.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_StatisticMaintenance] 
   @databaseName = 'SomeDatabase'
  ,@mode = 1 -- 0 устанавливаем режим анализа выборки данных, 1 - режим полного сканирования
  ,@ConditionTableName = '= ''TestTable''' -- Условие на имя таблицы
GO
```

#### Настройка приоритета и исключений для индексов

В таблице "MaintenanceIndexPriority" можно настроить приоритеты и признак исключения обслуживания для индексов.

- Имя базы данных (DatabaseName)
- Имя таблицы (TableName)
- Имя индекса (IndexName)
- Приоритет (Priority). Если приоритет ниже или равен 10, то для индекса будет считаться критичным и к нему будет по возможности использоваться операция перестроения. Операция реорганизации не будет применена. При выборке индексов для обслуживания, порядок обслуживания будет в первую очередь определяться приоритетом, а только после количеством изменений для этого индекса.
- Исключен из обслуживания (Exclude). Если установить в 1, то индекс не будет обслуживаться.

#### Логи обслуживания статистик

Лог операций обслуживания статистики хранится в таблице "MaintenanceActionsLog" и имеет примерно такой вид.

|   | Id | Period           | TableName                     | IndexName                                          | Operation         | RunDate          | StartDate        | FinishDate       | DatabaseName | UseOnlineRebuild | Comment | IndexFragmentation | RowModCtr | SQLCommand | TransactionLogUsageBeforeMB | TransactionLogUsageAfterMB |
| - | -- | ---------------- | ----------------------------- | -------------------------------------------------- | ----------------- | ---------------- | ---------------- | ---------------- | ------------ | ---------------- | ------- | ------------------ | --------- | --- | --- | --- |
| 1 | 1  | 03.01.2022 10:48 | service\_broker\_map          | I\_CLUST                                           | UPDATE STATISTICS | 03.01.2022 10:48 | 03.01.2022 10:48 | 03.01.2022 10:48 | tempdb       | 0                |         | 0                  | 129       | UPDATE STATISTICS \[sys\].\[service\_broker\_map\] \[I\_CLUST\]                                                    | 1 | 2 |
| 2 | 2  | 03.01.2022 10:48 | service\_broker\_map          | I\_SECONDARY                                       | UPDATE STATISTICS | 03.01.2022 10:48 | 03.01.2022 10:48 | 03.01.2022 10:48 | tempdb       | 0                |         | 0                  | 129       | UPDATE STATISTICS \[sys\].\[service\_broker\_map\] \[I\_SECONDARY\]                                                | 2 | 4 |
| 3 | 3  | 03.01.2022 10:48 | syscachedcredentials          | PK\_\_syscache\_\_F6D56B560A8C29D8                 | UPDATE STATISTICS | 03.01.2022 10:48 | 03.01.2022 10:48 | 03.01.2022 10:48 | msdb         | 0                |         | 0                  | 10638     | UPDATE STATISTICS \[dbo\].\[syscachedcredentials\] \[PK\_\_syscache\_\_F6D56B560A8C29D8\]                          | 4 | 6 |
| 4 | 4  | 03.01.2022 10:48 | syscachedcredentials          | \_WA\_Sys\_00000004\_01142BA1                      | UPDATE STATISTICS | 03.01.2022 10:48 | 03.01.2022 10:48 | 03.01.2022 10:48 | msdb         | 0                |         | 0                  | 393       | UPDATE STATISTICS \[dbo\].\[syscachedcredentials\] \[\_WA\_Sys\_00000004\_01142BA1\]                               | 6 | 9 |
| 5 | 5  | 03.01.2022 10:48 | syscollector\_blobs\_internal | PK\_syscollector\_blobs\_internal\_paremeter\_name | UPDATE STATISTICS | 03.01.2022 10:48 | 03.01.2022 10:48 | 03.01.2022 10:48 | msdb         | 0                |         | 0                  | 1         | UPDATE STATISTICS \[dbo\].\[syscollector\_blobs\_internal\] \[PK\_syscollector\_blobs\_internal\_paremeter\_name\] | 9 | 10 |

Лог содержит информацию:

- Период операции (Period)
- Имя таблицы (TableName)
- Имя индекса или имя служебной статистики, если не относится к индексу (IndexName)
- Имя операции. Для статистики это всегда "UPDATE STATISTICS" (Operation)
- Дата запуска обслуживания (RunDate)
- Дата старта (StartDate)
- Дата завершения. Если дата завершения NULL, то значит операция обслуживания не была завершена успешно (FinishDate)
- Имя базы (DatabaseName)
- Произвольный комментарий, обычно заполняется при ошибках (Comment)
- Количество измененных строк до обслуживания статистики (RowModCtr)
- SQL-команда обслуживания объекта статистики (SQLCommand)
- Размер лога транзакций до начала операции в МБ (TransactionLogUsageBeforeMB)
- Размер лога транзакций после завершения операции в МБ (TransactionLogUsageAfterMB)

Некоторые другие поля в логе обслуживания относятся к индексам и для обслуживания статистики не заполняются.

Лог позволяет определить эффективность обслуживания статистики и предпринять различные меры по ее актуализации.

### Управление заданиями

Функции для управления заданиями SQL Server. Более подробную информацию смотрите здесь: **[Управление и контроль заданий агента SQL Server](./Doc/Job-Settings.md)**.

#### Шаблоны заданий

В таблице **JobTemplates** содержаться шаблоны заданий, с помощью которых можно создать задания SQL Server одной командой:

```sql
EXECUTE [dbo].[sp_CreateOrUpdateJobsBySettings] 
   -- Пересоздать задания, даже если они уже существуют
   @force = 1
   -- Создать выключенными
  ,@createDisabled = 1
   -- Имя шаблона
   --,@filterTemplateName 
   -- Создавать задания, которые относятся ко всему экземлпяру SQL Server,
   -- то есть не привязаны к конкретной базе данных
  ,@createGeneralJobs = 1
  -- Создавать задания, которые относятся к конкретным базам данных
  ,@createDatabaseSpecificJobs = 0
  -- Фильтр для конкретной базы данных
  --,@filterDatabaseSpecificName
   -- Имя шаблона
   /*
   По умолчанию доступны:
   - "ОБЩИЕ"
   - "ЛЮБАЯ_БАЗА_ВОЗОБНОВЛЯЕМОЕ"
   - "ЛЮБАЯ_БАЗА_ПРОСТОЕ"
   - "ОБЩИЕ_ДОПОЛНИТЕЛЬНЫЕ_ЗАДАНИЯ"
   */
  --,@templateGroupName
  -- Использовать выключенные шаблоны
  --,@useDisabledTempletes = 0
  -- Игнорировать список по базе данных для шаблона.
  -- В таком случае можно для любой базы данных создать задания,
  -- которые предназначены для других баз.
  --,@ignoreDatabaseNameFilter = 0
  -- Режим отладки, где будут отображены SQL-команды для создания заданий
  -- и другая отладочная информация.
  --,@debugMode = 0
```

Рассмотрим несколько более простых примеров. Создадим общие задания для контроля и мониторинга SQL Server.

```sql
EXECUTE [dbo].[sp_CreateOrUpdateJobsBySettings] 
   -- Пересоздать задания, даже если они уже существуют
   @force = 1
   -- Создать выключенными
  ,@createDisabled = 1
   -- Создавать задания, которые относятся ко всему экземлпяру SQL Server,
   -- то есть не привязаны к конкретной базе данных
  ,@createGeneralJobs = 1
  -- Создавать задания, которые относятся к конкретным базам данных
  ,@createDatabaseSpecificJobs = 0
  -- Имя шаблона
   /*
   По умолчанию доступны:
   - "ОБЩИЕ"
   - "ЛЮБАЯ_БАЗА_ВОЗОБНОВЛЯЕМОЕ"
   - "ЛЮБАЯ_БАЗА_ПРОСТОЕ"
   - "ОБЩИЕ_ДОПОЛНИТЕЛЬНЫЕ_ЗАДАНИЯ"
   */
  ,@templateGroupName = 'ОБЩИЕ'
```

Будут созданы задания в выключенном состоянии (чтобы вручную их можно было отредактировать перед запуском):

* **Maintenance.ApplyNontplatrofmObjects** - применение настроек по созданию и изменений объектов баз данных. Ориентировано для платформы 1С.
* **Maintenance.Clear_FULL** - полных бэкапов.
* **Maintenance.Clear_TRN** - очистка бэкапов логов транзакций.
* **Maintenance.ControlJobsExecutionTimeout** - контроль времени выполнения обслуживания и других скриптов.
* **Maintenance.ControlTransactionLogUsage** - контроль использования логов транзакций процедурами обслуживания и другими скриптами.
* **Maintenance.GetDatabasesTableStatistics** - сбор информации о размере таблиц для всех баз на SQL Server.
* **XEventSessionRestart** - перезапуск сессий расширенных событий (только опредленных, которые были созданы средствами служебной базы).

Далее донастраиваем и включаем. Другой пример - это настройка обслуживания и бэкапирования для ббазы всего одной командой.

```sql
EXECUTE [dbo].[sp_CreateOrUpdateJobsBySettings] 
   -- Пересоздать задания, даже если они уже существуют
   @force = 1
   -- Создать выключенными
  ,@createDisabled = 1
   -- Создавать задания, которые относятся ко всему экземлпяру SQL Server,
   -- то есть не привязаны к конкретной базе данных
  ,@createGeneralJobs = 0
  -- Создавать задания, которые относятся к конкретным базам данных
  ,@createDatabaseSpecificJobs = 1
  -- Имя шаблона
   /*
   По умолчанию доступны:
   - "ОБЩИЕ"
   - "ЛЮБАЯ_БАЗА_ВОЗОБНОВЛЯЕМОЕ"
   - "ЛЮБАЯ_БАЗА_ПРОСТОЕ"
   - "ОБЩИЕ_ДОПОЛНИТЕЛЬНЫЕ_ЗАДАНИЯ"
   */
   -- Если нужно самое простое обслуживание, то нужно выбрать "ЛЮБАЯ_БАЗА_ПРОСТОЕ"
  ,@templateGroupName = 'ЛЮБАЯ_БАЗА_ВОЗОБНОВЛЯЕМОЕ'
  -- Режим отладки, где будут отображены SQL-команды для создания заданий
  -- Фильтр для конкретной базы данных
  ,@filterDatabaseSpecificName = 'TestDB'
  -- Использовать выключенные шаблоны
  ,@useDisabledTempletes = 1
  -- Игнорировать список по базе данных для шаблона.
  -- В таком случае можно для любой базы данных создать задания,
  -- которые предназначены для других баз.
  ,@ignoreDatabaseNameFilter = 1
```

В результате для базы **TestDB** будут созданы задания:

* **Maintenance.TestDB_FillDatabaseObjectsState** - сбор информации о состоянии базы данных.
* **Maintenance.TestDB_FULL** - полный бэкап базы данных.
* **Maintenance.TestDB_TRN** - бэкап лога транзакций.
* **Maintenance.TestDB_IndicesAndStatistics_Daily** - ежедневное обслуживание индексов и статистик.
* **Maintenance.TestDB_IndicesAndStatistics_SpecialLegacyObjects_Daily** - ежедневное обслуживание индексов и статистик для объектов с устаревшими типами, не поддерживающих онлайн перестроения.
* **Maintenance.TestDB_IndicesAndStatistics_Weekly** - еженедельное обслуживание индексов и статистик.
* **Maintenance.TestDB_IndicesAndStatistics_SpecialLegacyObjects_Weekly** - еженедельное обслуживание индексов и статистик для объектов с устаревшими типами, не поддерживающих онлайн перестроения.
* **Maintenance.TestDB_StatisticsOnly_Daily** - ежедневное обслуживание статистик.

Задания также будут созданы отключенными, чтобы их настроить перед первым запуском.

Кроме этого, можно создать некоторые специфические задания.

```sql
EXECUTE [dbo].[sp_CreateOrUpdateJobsBySettings] 
   -- Пересоздать задания, даже если они уже существуют
   @force = 1
   -- Создать выключенными
  ,@createDisabled = 1
   -- Создавать задания, которые относятся ко всему экземлпяру SQL Server,
   -- то есть не привязаны к конкретной базе данных
  ,@createGeneralJobs = 1
  -- Создавать задания, которые относятся к конкретным базам данных
  ,@createDatabaseSpecificJobs = 0
  -- Имя шаблона
  ,@templateGroupName = 'ОБЩИЕ_ДОПОЛНИТЕЛЬНЫЕ_ЗАДАНИЯ'
  -- Режим отладки, где будут отображены SQL-команды для создания заданий
  -- Фильтр для конкретной базы данных
  --,@filterDatabaseSpecificName = 'TestDB'
  -- Использовать выключенные шаблоны
  ,@useDisabledTempletes = 1
```

Из шаблонов будут созданы несколько заданий:

* **Maintenance.FillDatabaseObjectsState** - задание собираем информации о состоянии объектов ВСЕХ баз данных на экземпляре SQL Server.
* **Maintenance.FullBackupAllDatabases** - полный бэкап ВСЕХ баз данных на экземпляре SQL Server.
* **Maintenance.TransactionLogBackupAllDatabases** - бэкап логов транзакций ВСЕХ баз данных на экземпляре SQL Server.

Посмотрите стандартные шаблоны в таблице **JobTemplates** и по аналогии можете добавлять свои.

### Сервисные функции

Различные сервисные функции для упрощения сопровождения SQL Server.

#### Контроль времени выполнения

Имеется процедура контроля времени выполнения облуживания и любых других скриптов.

Вызов процедуры контроля, проверяющей текущие соединения на доступность работы:

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_ControlJobsExecutionTimeout]
```

При обнаружении соединений, работа которых уже недоступна, они будут принудительно завершены.

В процедурах обслуживания время работы задается параметрами **@timeFrom** и **@timeTo**. В остальных случаях время работы можно ограничить следующим образом:

```sql
-- Добавляем ограничение работы текущего скрипта
EXECUTE [dbo].[sp_AddSessionControlSetting] 
   -- Имя базы данных
   @databaseName = 'TestDB'
   -- Разрешенный диапазон работы
  ,@workFrom = '16:00:00'
  ,@workTo = '16:34:00'
   -- Таймаут ожидания перед принудительным завершением
  ,@timeTimeoutSec = 60

-- Какая-то большая работа :)
WAITFOR DELAY '00:05:00'

-- Убираем текущие ограничения работы для соединения.
-- Если их не убрать, то они будут автоматически очищены позже процедурой контроля.
EXECUTE [dbo].[sp_RemoveSessionControlSetting] 
```

При вызове процедуры **sp_AddSessionControlSetting** в таблицу **SessionControlSettings** добавляется информация об ограничениях работы текущего соединения. При следующих вызовах процедуры **sp_ControlJobsExecutionTimeout** именно по этим данным будут выполнены проверки и поиск соединений для завершения.

#### Контроль логов транзакций

В операциях обслуживания индекса процедуры "sp_IndexMaintenance" имеются несколько параметров для контроля работы:

- Время выполнения контролируется параметрами начала и окончания работы скрипта (@timeFrom и @timeTo).
- Условия выполнения при заполненном логе транзакций контролируются параметром @maxTransactionLogSizeUsagePercent, который содержит процент заполнения журнала транзакций, после которого операции обслуживания останавливаются.

Данный вид контроля работает отлично, но не во всех случаях. Например, если перестроение индекса идет длительное время и журнал транзакций при этом уже заполнен более чем на указанный в ограничениях процент, то никаких проверок по логу транзакций не сработает. Это происходит потому что процент заполнения лога транзакций проверяется перед каждой операцией обслуживания, а не во время их выполнения.

В тех случаях, когда контроль нужно выполнять на постоянной основе и это может оказаться критичным для работоспособности базы данных, то можно включить дополнительный контроль через процедуру "sp_ControlTransactionLogUsage". Суть работы процедуры заключается в следующем:

1. Сначала в таблице **LogTransactionControlSettings** нужно указать список параметров для контроля:

- **DatabaseName** - имя базы данных, для которой необходимо выполнять контроль.
- **MinDiskFreeSpace** - минимальный объем свободного места на диске (в МБ), на котором расположен файл лога транзакций.
- **MaxLogUsagePercentThreshold** - максимальный процент использования файла лога транзакций, после которого начинается проверка свободного места на диске. По умолчанию 90%.
- **MinAllowDataFileFreeSpaceForResumableRebuildMb** - минимальный объем свободного места в файле данных (в самом файле и место на диске, где этот файл находится), при котором доступно возобновляемое обслуживание. Возобновляемые операции используют дополнительное простнатство в файлах данных, а этот контроль позволяет защититься от переполнения диска и остановки работы.

По умолчанию есть настройка для всего сервера, у которой в поле **DatabaseName** установлено значение **NULL**. Настройка по умолчанию имеет слудующие параметры:

* **MinDiskFreeSpace** = 307200 МБ
* **MaxLogUsagePercentThreshold** = 75%
* **MinAllowDataFileFreeSpaceForResumableRebuildMb** = 307200 МБ

2. Затем необходимо запускать процедуру контроля использования логов транзакций. Можно это делать вручную, но лучше сделать задание на автоматический запуск раз в 15 секунд. Контроль для всех баз выглядит так:

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_ControlTransactionLogUsage] 
```

Имеется возможность указать конкретуню базу и включить вывод отладочных сообщений.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_ControlTransactionLogUsage] 
   @databaseNameFilter = 'BSL-ORIG'
  ,@showDiagnosticMessages = 1
```

Отладочные сообщения нужны лишь для помощи отладки проверок.

Сбрасываться будут только текущие запросы обслуживания индексов (операции перестроения и организации индексов в текущей базе). При каждом запуске выполняется проверка для каждого отдельного файла лога транзакций в базе (файлов логов транзакций может быть несколько):

- Место на диске больше минимального значения, указанного в таблице настроек.
- Если места свободного меньше, чем нужно, то выполняется проверка заполненности лога транзакций. Если лог заполнен более чем указанный % в настройках, то все запросы обслуживания баз данных принудительно завершаются.
- Кроме этого выполняется проверка заполнености лога транзакций с учетом максимального его размера. Максимальный размер лога определяется ограничениями роста файла лога транзакций, которые могут быть установлены явно или установлены не явно. Например, если ограничений не установлено, то максимальный размер файла лога равен 2 ТБ (это системные ограничения). В тех случаях, если файл лога транзакций становится заполненным более чем на 90% от его максимально возможного размера, то текущие операции обслуживания также прекращаются.
- Свободное место для данных (место в самом файле данных и место на диске, где файл находится). Если место меньше установленного значения в параметрах ограничений, то возобновляемые операции перестроения индексов будут остановлены.

Таким образом, можно контролировать рост файла лога транзакций не допуская его переполнения до 100%. Особенно это может быть критично, если база включена в группу доступности AlwaysOn. При заполнении лога транзакций до 100% ошибку можно будет "вылечить" чаще всего путем "разбора" группы доступности и следующим освобождением файла лога. Такой маневр иногда может стоить большого количества времени и простоя реплик.

Кроме того, можно в своих собственных скриптах установить параметры контроля транзакций по аналогии с временем выполнения, что было рассмотрено в предыдущем разделе.

```sql
-- Добавляем ограничение работы текущего скрипта
EXECUTE [dbo].[sp_AddSessionControlSetting] 
   -- Имя базы данных
   @databaseName = 'TestDB'
  -- Разрешаем скрипту работать, 
  -- если лог транзакций заполнен не более чем на 80%
  ,@maxLogUsagePercent = 80
  -- ИЛИ заполненность не превышает 100 ГБ
  ,@maxLogUsageMb = 102400
  

-- Какая-то большая работа :)
WAITFOR DELAY '00:05:00'

-- Убираем текущие ограничения работы для соединения.
-- Если их не убрать, то они будут автоматически очищены позже процедурой контроля.
EXECUTE [dbo].[sp_RemoveSessionControlSetting] 
```

Таким образом, мы имеем контроль лога транзакций для операций обслуживания, а также и для любых других скриптов.

#### Контроль блокировок запросов

Еще один контроль - это блокировка запросов. Может быть ситуация, когда мы не хотим, чтобы наш скрипт блокировал работу других скриптов. А если такое происходит, чтобы наш скрипт был завершен принудительно.

По аналогии с примерами выше создадим скрипт с ограничениями на блокировку других запросов.

```sql
-- Добавляем ограничение работы текущего скрипта
EXECUTE [dbo].[sp_AddSessionControlSetting] 
   -- Имя базы данных
   @databaseName = 'TestDB'
  -- Завершить текущее соединение, если оно блокируем работу других запросов
  ,@abortIfLockOtherSessions = 1
  -- Допустимое время блокировки других запросов в секундах
  ,@abortIfLockOtherSessionsTimeoutSec = 3
  

-- Какая-то большая работа :)
WAITFOR DELAY '00:05:00'

-- Убираем текущие ограничения работы для соединения.
-- Если их не убрать, то они будут автоматически очищены позже процедурой контроля.
EXECUTE [dbo].[sp_RemoveSessionControlSetting] 
```

Здесь мы поставили ограничение, чтобы наш скрипт не блокировал работу других запросов более чем на 3 секунды. В противном случае он будет принудительно завершен.

За фактический контроль отвечает процедура:

```sql
EXECUTE [dbo].[sp_ControlSessionLocks] 
```

Достаточно запускать ее раз 15 секунд для оптимальной работы. Как только убдет обнаружено соединение с установленными ограничениями, то процедура будет работать до тех пор, пока такие соедининения активыны и раз в 3 секунды проверять, не нагрушили ли они ограничения.

#### Реорганизация индексов и блокировки на уровне страниц

В некоторых базах данных у иднексов может быть отключен параметр [**AllowPageLocks**](https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-indexoption-transact-sql?view=sql-server-ver16). При выключенном параметре SQL Server не сможет выполнять блокировки на уровне страниц для этого объекта, а следовательно невозможно выполнение операции реорганизации индексов, которая блокировки на уровне страниц и использует.

Для решения данной проблемы в операциях обслуживания процедуры **sp_IndexMaintenance** реализован следующий алгоритм:

- Если для индекса необходимо выполнить операцию реорганизации, а параметр **AllowPageLocks** у объекта выключен, то перед этим выполняется включение этой настройки.

```sql
ALTER INDEX [IndexName] ON [dbo].[TableName] SET (ALLOW_PAGE_LOCKS = ON);
```

- Выполняем непосредственно операцию реорганизации индекса.

```sql
ALTER INDEX [IndexName] ON [dbo].[TableName] REORGANIZE
```

- Возвращаем настройку **AllowPageLocks** в исходное состояние.

```sql
ALTER INDEX [IndexName] ON [dbo].[TableName] SET (ALLOW_PAGE_LOCKS = OFF);
```

По итогу объект будет иметь те же настройки, которые были у него до запуска обслуживания. При этом, если настройка **AllowPageLocks** у объекта перед запуском обслуживания была включена, то перечисленные дополнительные действия не выполняются.

Если в момент операции обслуживания произойдет сбой или соединение будет завершено администратором, то операция восстановления исходного состояния настройки **AllowPageLocks** будет находиться в дополнительной очереди на выполнение (в таблице **MaintenanceActionsToRun**). При следующем запуске любого обслуживания индексов для базы данных (то есть вызова процедуры **sp_IndexMaintenance**) отложенная команда будет выполнена и настройка восстановлена. Это сделано для максимальной надежности работы обслуживания, чтобы оно не ломало настройки объектов в случае сбоя.

Для проверки работы механизма отсложенных команд обслуживания можно смотреть ту же таблицу логов, что и для остальных операций обслуживания - **MaintenanceActionsLog**. В ней для подобных операций в колонке **Operation** будет содержаться значение вида **MAINTENANCE ACTION TO RUN (REORGANIZE INDEX)**, а в колонке **SQLCommand** можно увидеть исходную команду, которая была выполнена.

Вообще отключение возможности блокировок на уровне страниц является точечным решением и не применяется повсеместно, т.к. ведет к увеличению потребления памяти СУБД и некоторым другим эффектам. Отключение блокировок на уровне страниц решение часто спорное, если используется для всей базы данных. Вот дополнительная информация по этой теме:

* [Risk of disabling page locking](https://dba.stackexchange.com/questions/72369/risk-of-disabling-page-locking)
* [Difference Between Row Level and Page Level Locking and Consequences](https://dba.stackexchange.com/questions/6512/difference-between-row-level-and-page-level-locking-and-consequences)
* [How to force the use of row locks?](https://dba.stackexchange.com/questions/29293/how-to-force-the-use-of-row-locks)
* [Is it possible to force row level locking in SQL Server?](https://stackoverflow.com/questions/3114826/is-it-possible-to-force-row-level-locking-in-sql-server)
* [ROW_LOCKS & PAGE_LOCKS](https://social.msdn.microsoft.com/Forums/sqlserver/en-US/1b74e212-6c70-4db6-8d1a-23188fa4ef27/rowlocks-amp-pagelocks?forum=transactsql)
* [Resolve SQL Server Database Index Reorganization Page Level Locking Problem](https://www.mssqltips.com/sqlservertip/4247/resolve-sql-server-database-index-reorganization-page-level-locking-problem/)
* [ALLOW_PAGE_LOCKS : to use or not to use](https://www.sqlservercentral.com/forums/topic/allow_page_locks-to-use-or-not-to-use)
* [What is the impact of temporarily setting ALLOW_PAGE_LOCKS ON](https://dba.stackexchange.com/questions/135934/what-is-the-impact-of-temporarily-setting-allow-page-locks-on)

Принимая решение об отключении блокировок на уровне страниц для объекта нужно это обосноваь конкретной необходимостью и не принимать в качестве универсального решения. По ссылкам Выше можно найти более подробную информацию, а я лишь процитирую [Remus Rusanu]() и дам [ссылку на ответ]:

```
I would never turn this OFF on my database. The solution is always to properly design the schema and the queries so that scans (which are the culprits for escalation) don't occur to start with.
```

Думайте, что делаете. А когда делаете - думайте еще!

#### Исправление системного кэша объектов для реплик AlwaysOn

При выполнении запросов **SELECT** к репликам AlwaysOn, находящимся в режиме асинхронной передачи данных, могут возникнуть ошибки вида.

```text
Не удалось найти статистику "_WA_Sys_00000007_7C1B37B1" в системных каталогах.DB-Lib error message 20018, severity 16:
General SQL Server error: Check messages from the SQL Server

или

Could not locate statistics "_WA_Sys_00000007_7C1B37B1" in the system catalogs. DB-Lib error message 20018, severity 16:
General SQL Server error: Check messages from the SQL Server


Примечание: _WA_Sys_00000007_7C1B37B1 - имя автоматически сгенерированного объекта статисти, которое может отличаться при появлении ошибки.
```

Причина проблемы - это активные транзакции, которые не позволяют применить записи журнала и обновить недействительный кэш объектов статистики на вторичной реплике. [Подробная информация есть в официальной документации](https://learn.microsoft.com/en-us/troubleshoot/sql/database-engine/availability-groups/error-2767-query-secondary-replica-fails).

Для исправления ситуаций можно запускать следующую хранимую процедуру с некоторой периодичностью (например, раз в 30 минут).

```sql
EXECUTE [dbo].[sp_FixMissingStatisticOnAlwaysOnReplica] 
GO
```

При таком вызове будут проверены все базы данных, учавствующие в группах доступности AlwaysOn и использующие асинхронную передачи данных. Проверка выполняет поиск объектов статистики, которые по факту удалены, но до сих пор имеет информацию в кэше объектов базы данных.

Кроме этого, можно фильтр по имени базы данных, если такую процедуру нужно выполнять точечно.

```sql
EXECUTE [dbo].[sp_FixMissingStatisticOnAlwaysOnReplica] 
   @databaseName = 'MyProdDatabase'
GO
```

Информация о найденных "битых" объектах статистики будет сохраняться в таблицу **AlwaysOnReplicaMissingStats** в следующем виде:

- **DatabaseName** - имя проблемной базы данных.
- **TableName** - имя проблемной таблицы.
- **StatsName** - имя проблемного объекта статистики.
- **CreatedDate** - дата обнаружения проблемы.

При обнаружении проблемы будет вызвана системная процедура **[FREESYSTEMCACHE(<ИмяБазы>)](https://learn.microsoft.com/ru-ru/sql/t-sql/database-console-commands/dbcc-freesystemcache-transact-sql?view=sql-server-ver16)**.

#### Сжатие и "умный" шринк (shrink) базы данных

Имеется ряд процедур для сжатия данных и шринка файлов.

Первая - это сжатие данных в файле методом **PAGE**.

```sql
EXECUTE [dbo].[sp_CompressDatabaseObjects] 
   -- База данных
   @databaseName = 'TestDB'
   -- Диапазон времени для работы
  ,@timeFrom = '12:00:00'
  ,@timeTo = '15:00:00'
   -- Использовать онлайн-перестроение, чтобы не блокировать работу запросов
  ,@useOnlineRebuild = 1
   -- Использовать возобновляемое перестроение.
   -- Тогда если прервать сжатие, то при повторном запуске работа
   -- будет продолжена с места остановки.
  ,@userResumableRebuild = 1
   -- Степень параллелизма при перестроении
  ,@maxDop = 4
```

Вторая - это "умный" шринк базы данных с пошаговым выполнением и контролем работы.

```sql
EXECUTE [dbo].[sp_ShrinkDatabaseDataFile] 
	-- База данных
   @databaseName = 'TestDB'
   -- Имя файла данных, если их в базе несколько
   --,@databaseFileName
   -- Диапазон времени для работы
  ,@timeFrom = '12:00:00'
  ,@timeTo = '15:00:00'
  -- Задержка в секундах между шагами "шринка" файла данных.
  -- Позволяет сделать окно между запусками, чтобы снизить влияние на работу.
  ,@delayBetweenSteps = 60
  -- Размер шага при "шринке" в мегабайтах. Чем меньше шаг, тем быстрее он будет выполнен.
  -- И тем более контролируемый процесс, а также меньше влияние на работу других запросов.
  ,@shrinkStepMb = 100
  -- Остановить "шринк", если будет достигнут указанный процент свободного места в файле данных
  ,@stopShrinkThresholdByDataFileFreeSpacePercent = 10
```

К этому скрипту также можно добавить контроль блокировок, что описан выше.

Третий - это скрипт, который выполняет сначала сжатие данных, а потом шринк файлов.

```sql
EXECUTE [dbo].[sp_CompressAndShrinkDataFile] 
	-- База данных
   @databaseName = 'TestDB'
   -- Имя файла данных, если их в базе несколько
   --,@databaseFileName
   -- Диапазон времени для работы
  ,@timeFrom = '12:00:00'
  ,@timeTo = '15:00:00'
   -- Использовать онлайн-перестроение, чтобы не блокировать работу запросов
  ,@useOnlineRebuild = 1
   -- Использовать возобновляемое перестроение.
   -- Тогда если прервать сжатие, то при повторном запуске работа
   -- будет продолжена с места остановки.
  ,@userResumableRebuild = 1
   -- Степень параллелизма при перестроении
  ,@maxDop = 4
   -- Имя файла данных, если их в базе несколько
   --,@databaseFileName
  -- Задержка в секундах между шагами "шринка" файла данных.
  -- Позволяет сделать окно между запусками, чтобы снизить влияние на работу.
  ,@delayBetweenSteps = 60
  -- Размер шага при "шринке" в мегабайтах. Чем меньше шаг, тем быстрее он будет выполнен.
  -- И тем более контролируемый процесс, а также меньше влияние на работу других запросов.
  ,@shrinkStepMb = 100
  -- Остановить "шринк", если будет достигнут указанный процент свободного места в файле данных
  ,@stopShrinkThresholdByDataFileFreeSpacePercent = 10
```

Фактически сделан для удобства, чтобы выполнять оба действия одной командой.

#### Печать длинных сообщений

Системная процедура **PRINT** выводит ограниченный по размеру текст. Для обхода этого ограничения, например для сложной отладки, можно вспользоваться процедурой **sp_AdvancedPrint**.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_AdvancedPrint] 
   @sql = 'HELLO HELLO HELLO'
```

### Сервисные функции для баз 1С

Различные сервисные функции для баз 1С. В репозитории уже есть некоторые [решения для поддержки неплатформенных настроек и объектов для баз 1С](./../../1С-Extended-Database-Settings-Maintenance/Readme.md). Здесь несколько других полезных функций.

#### Функции рабботы с уникальными идентификаторами

Платформа 1С хранит GUID'ы в типе **binary(16)**, а не в стандартном типе **uniqueidentifier**. Чтобы преобразовать "1С'ный" GUID в обычный и обратно используются две функции.

```sql
SELECT 
  -- Исходное значение
	0xAE4D415A6E83AF724FBC9EC0040727CC,
  -- Конвертируем в Uniqueidentifier
	[SQLServerMaintenance].[dbo].[fn_ConvertBinary1CIdToUniqueidentifier](0xAE4D415A6E83AF724FBC9EC0040727CC) AS [AsUniqueidentifier],
  -- Конвертируем в Binary16
	[SQLServerMaintenance].[dbo].[fn_ConvertUniqueidentifierToBinary1CId]('040727CC-9EC0-4FBC-AE4D-415A6E83AF72') AS [As1CId]
```

### Бэкапирование

Для упрощения решения некоторых задач с бэкапированием, сделана оберточная процедура для упрощенного вызова формирования бэкапов всех типов (полный, разностный или лога транзакций) со всеми доступными опциями для формирования бэкапов.

Ниже несколько примеров использования данной процедуры.

#### Формирование бэкапов

Ниже самый просто пример формирования бэкапа с указанием минимального количества параметров.

```sql
-- Формирование полного бэкапа
EXECUTE [SQLServerMaintenance].[dbo].[sp_BackupDatabase] 
   -- Имя базы данных. Обязательный параметр.
   @databaseName = 'FIASToolSetService_Prod'
   -- Каталог для хранения бэкапов. Обязательный параметр.
  ,@backupDirectory = 'C:\Backup'
  -- Тип бэкапа. Обязательный параметр.
  -- Возможные значения:
  --	* FULL - полный бэкап
  --	* DIFF - разностный бэкап
  --	* TRN - бэкап лога транзакций
  ,@backupType = 'FULL'

-- Разностного
EXECUTE [SQLServerMaintenance].[dbo].[sp_BackupDatabase] 
   @databaseName = 'FIASToolSetService_Prod'
  ,@backupDirectory = 'C:\Backup'
  ,@backupType = 'DIFF'

-- Лога транзакций
EXECUTE [SQLServerMaintenance].[dbo].[sp_BackupDatabase] 
   @databaseName = 'FIASToolSetService_Prod'
  ,@backupDirectory = 'C:\Backup'
  ,@backupType = 'TRN'
```

В результате будет создан каталог **C:\Backup\FIASToolSetService_Prod** с файлом полгого бэкапа вида **FIASToolSetService_Prod_backup_2023_08_31_231757_917514.bak**.

Также есть более гибкие возможности настройки формирования бэкапа. В листинге ниже приведены все возможности процедуры.

```sql
EXECUTE [SQLServerMaintenance].[dbo].[sp_BackupDatabase] 
   -- Имя базы данных. Обязательный параметр.
   @databaseName = 'FIASToolSetService_Prod'
   -- Каталог для хранения бэкапов. Обязательный параметр.
  ,@backupDirectory = 'C:\Backup'
  -- Тип бэкапа. Обязательный параметр.
  -- Возможные значения:
  --	* FULL - полный бэкап
  --	* DIFF - разностный бэкап
  --	* TRN - бэкап лога транзакций
  ,@backupType = 'FULL'
  -- Использовать подкаталоги для каждой базы данных.
  -- Не обязательный параметр, по умолчанию используется.
  ,@useSubdirectory = 1
  -- Использование сжатия бэкапов. Не обязательный параметр.
  -- Возможные значения:
  -- AUTO - использовать глобальную настройку на сервере. Значение по умолчанию.
  -- ENABLE - использовать сжатие.
  -- DISABLE - НЕ использовать сжатие.
  ,@backupCompressionType = 'ENABLE'
  -- Режим только копирования. Не обязательный. По умолчанию выключен. Не обязательный параметр.
  -- В даном режиме формирование бэкапа не будет влиять на цепочку транзакций.
  ,@copyOnly = 0
  -- Сформировать контрольную сумму. По умолчанию выключен. Не обязательный параметр.
  ,@checksum = 0
  -- Продолжить при возникновении ошибок. По умолчанию выключен. Не обязательный параметр.
  ,@continiueOnError = 0  
  -- Проверять бэкап после формирования. По умолчаниювыключен. Не обязательный параметр.
  ,@verify = 1  
  -- Только показать текст скрипта для формирования бэкапа.
  -- Сам бэкап при этом сформирован не будет.
  ,@showScriptOnly = 1

  -- Параметры для управления потоком резервного копирования.
  -- Могут использоваться для оптимизации времени формирования бэкапа,
  -- но со значительным влиянием на работу ситсемы ввода-вывода.
  -- Подробнее можете прочитать здесь: 
  -- https://www.mssqltips.com/sqlservertip/4935/optimize-sql-server-database-restore-performance/
  --,@blockSize
  --,@maxTransferSize
  --,@bufferCount
```

Практически все параметры дублируют настройки, которые присутствуют в стандартных планах обслуживания SQL Server.

#### Очистка бэкапов

Также для целей управления бэкапами добавлена процедура очистки устаревших файлов бэкапов.

Ниже примеры использования процедуры с описанием параметров.

```sql
EXECUTE [dbo].[sp_ClearFiles] 
  -- Каталог для очистки. Обязательный параметр.
   @folderPath = 'C:\Backup'
  -- Расширение файлов для удаления. Обязательный параметр.
  ,@fileExtension = 'bak'
  -- Количество дней хранения файлов. Не обязательный параметр.
  -- По умолчанию будут считаться устаревшими все файлы.
  ,@cutoffDateDays = 28
```

В данном случае будут удалены файлы полных бэкапов ***.bak** старше 30 дней. Это же можно достичь, указав явно дату, до которой файлы бэкапов будут считаться устаревшими.

```sql
DECLARE @cutoffDate datetime = DATEADD(week, -4, GETDATE());
EXECUTE [SQLServerMaintenance].[dbo].[sp_ClearFiles] 
  -- Каталог для очистки. Обязательный параметр.
   @folderPath = 'C:\Backup'
  -- Расширение файлов для удаления. Обязательный параметр.
  ,@fileExtension = 'bak'
  -- Дата, до которой файлы считаются устарешвими.
  -- Не обязательный параметр. По умолчанию - текущая дата.
  -- Если не заполнить, то удалятся все файлы без анализа даты создания.
  ,@cutoffDate = @cutoffDate
```

Вот полный синтаксис данной процедуры.

```sql
DECLARE @cutoffDate datetime = DATEADD(week, -4, GETDATE());
EXECUTE [dbo].[sp_ClearFiles] 
  -- Каталог для очистки. Обязательный параметр.
   @folderPath = 'C:\Backup'
  -- Расширение файлов для удаления. Обязательный параметр.
  ,@fileExtension = 'bak'
  -- Количество дней хранения файлов. Не обязательный параметр.
  -- По умолчанию будут считаться устаревшими все файлы.
  -- Одновремено можно указать либо @cutoffDateDays, либо @cutoffDate.
  ,@cutoffDateDays = 28
  -- Дата, до которой файлы считаются устарешвими.
  -- Не обязательный параметр. По умолчанию - текущая дата.
  -- Если не заполнить, то удалятся все файлы без анализа даты создания.
  -- Одновремено можно указать либо @cutoffDateDays, либо @cutoffDate.
  ,@cutoffDate = @cutoffDate
  -- Использовать для очистки подкаталоги первого уровня.
  -- По умолчанию включен. Не обязательный параметр.
  ,@includeSubfolders=1
  -- Только показать скрипт для удаления файлов.
  ,@scriptOnly = 1,
  -- Типы удаляемых файлов. 
  -- Есть вариант для файлов бэкапов (0, используется по умолчанию),
  -- либо файлы логов задания обслуживания (1).
  @fileType = 0
```

Почти все параметры дублируют стандартную задачу очистки SQL Server.